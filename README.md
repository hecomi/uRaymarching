uRaymarching
============
**uRaymarching** is a raymarching shader templates using [uShaderTemplate](https://github.com/hecomi/uShaderTemplate). The following functions are implemented:

- Create a ray-marching object **by simply writing a distance function**
- Legacy pipelines (**Forward** / **Deferred**) and **URP** (**Forward / Deferred**) are supported
  - HDRP is not yet supported
- Intersects polygonal objects because it writes depth
- VR support
- Lit / Unlit (+ Transparent)
- Shadows for Directional / Spot / Point lights
- Object-space and full-screen (Full screen only for legacy pipelines)


Screenshots
-----------
The following shapes are rendered inside a 12-polygon cube.

<img src="https://raw.githubusercontent.com/wiki/hecomi/uRaymarching/hex_floor.gif" width="720" />
<img src="https://raw.githubusercontent.com/wiki/hecomi/uRaymarching/morph.gif" width="720" />

Check more examples here:

- [https://github.com/hecomi/uRaymarchingExamples](https://github.com/hecomi/uRaymarchingExamples)


Install
-------
- Unity Package
  - Download the following .unitypackage-s.
    - [uShaderTemplate](https://github.com/hecomi/uShaderTemplate/releases).
    - [uRaymarching](https://github.com/hecomi/uRaymarching/releases)
- Git URL (UPM)
  - Add the following git URLs to Package Manager.
    - `https://github.com/hecomi/uShaderTemplate.git#upm`
    - `https://github.com/hecomi/uRaymarching.git#upm`
- Scoped Registry (UPM)
  - Add a scoped registry to your project.
    - URL: `https://registry.npmjs.com`
    - Scope: `com.hecomi`
  - Install uRaymarching in Package Manager.

How to use
----------
1. Select *Create > Shader > uShaderTemplate > Generator* in the Project view.
2. Input *Shader Name* and select *Shader Template* from Inspector.
3. Edit items in *Conditions*, *Variables*, *Properties*, *Distance Function*, and *Post Effect*.
4. Press *Export* button or *Ctrl + R* to create shader from the `Generator`.
5. Create material in the Project view (or press *Create Material* button).
6. Create *Cube* in the Hierarchy view.
7. Apply the generated material to the cube.

Please also see [uShaderTemplate](https://github.com/hecomi/uShaderTemplate) to learn the detail of shader generation function.


Inspector
---------
<img src="https://raw.githubusercontent.com/wiki/hecomi/uRaymarching/inspector.png" width="720" />

The UI is generated by [uShaderTemplate](https://github.com/hecomi/uShaderTemplate) automatically from template files located in the *Assets/uRaymarching/Editor/Resources/ShaderTemplates*.


Shader Templates
---------------
- **Forward > Standard**
  - The lighting is done by the same method as a standard surface shader in *ForwardBase/Add* pass.
- **Forward > Unlit**
  - No lighting by default so you have to write output colors manually.
- **Deferred > Standard**
  - The lighting is done by the same method as a standard surface shader.
- **Deferred > Direct GBuffer**
  - Write values directly into GBuffers without effects like GI and LightProbe.
- **UniversalRP > Lit**
  - Same lighting as the built-in `Universal Render Pipelin/Lit` shader.
- **UniversalRP > Unlit**
  - No lighting, and same as the built-in `Universal Render Pipelin/Unlit` shader.

The items in *Conditions* and *Variables* are different depending on the selected template. Please see each page for further details:

- **[Legacy (Forward / Deferred)](https://github.com/hecomi/uRaymarching/blob/master/Documents/Legacy.md)**
- **[UniversalRP](https://github.com/hecomi/uRaymarching/blob/master/Documents/UniversalRP.md)**


Properties
----------
This block is inserted into a `Property` section in a shader.

```shaderlab
[Header(Additional Parameters)]
_Grid("Grid", 2D) = "" {}
```

<img src="https://raw.githubusercontent.com/wiki/hecomi/uRaymarching/property.png" width="720" />


Distance Function
-----------------
Write a distance function here. The following code is the one generating the example of morphing sphere in *Screenshots* section in this document.

```hlsl
inline float DistanceFunction(float3 pos)
{
    float r = abs(sin(2 * PI * _Time.y / 2.0));
    float d1 = RoundBox(Repeat(pos, float3(6, 6, 6)), 1 - r, r);
    float d2 = Sphere(pos, 3.0);
    float d3 = Plane(pos - float3(0, -3, 0), float3(0, 1, 0));
    return SmoothMin(SmoothMin(d1, d2, 1.0), d3, 1.0);
}
```

*<a href="Assets/uRaymarching/Shaders/Include/Math.cginc">Math.cginc</a>* and *<a href="Assets/uRaymarching/Shaders/Include/Primitives.cginc">Primitives.cginc</a>* are included in the generated shader, so in this example some functions like `RoundBox()` and `Repeat()` come from these include files (of cource you can write them by yourself).


Post Effect
-----------
*Post Effect* is similar to a surface function in a surface shader. The following code is used in the hexagon-tile example in *Screenshots* section.

```hlsl
float4 _TopColor;

inline void PostEffect(RaymarchInfo ray, inout PostEffectOutput o)
{
    float3 localPos = ToLocal(ray.endPos);
    o.Emission += smoothstep(0.48, 0.50, localPos.y) * _TopColor;
    o.Occlusion *= 1.0 - 1.0 * ray.loop / ray.maxLoop;
}
```

`RaymarchInfo` is the input and the output of a raymarching calculation and this is defined in *Struct.cginc*.

```hlsl
struct RaymarchInfo
{
    // Input
    float3 startPos;    // start position of ray
    float3 rayDir;      // ray direction
    float3 projPos;     // ComputeScreenPos-applied position
    float3 polyNormal;  // normal on polygon surface
    float minDistance;  // minimum ray distance (comes from material setting)
    float maxDistance;  // maximum ray distance (changes by the raymarching setting)
    int maxLoop;        // maximum number of loop (comes from material setting)

    // Output
    int loop;           // total number of loop of the calculation (<= maxLoop)
    float3 endPos;      // last position (= surface of the distance function)
    float lastDistance; // the final distance of the raymarching
    float totalLength;  // total ray length
    float depth;        // depth (encoded)
    float3 normal;      // normal (encoded)
};
```

So `ray.loop / ray.maxLoop` is a normalized value and becomes close to 0.0 on the position where a ray reaches easily and becomes close to 1.0 when hard. So you can use it as a factor of a rechability or `1.0 - ray.loop / ray.maxLoop` as an simple and a light-weight occlusion factor.

`PostEffectOutput` is defferent depending on the selected shader template. For example, it is an alias of `SurfaceOutputStandard` in *Standard* template. Please see the following pages for more details.

- [Legacy (Forward / Deferred)](https://github.com/hecomi/uRaymarching/blob/master/Documents/Legacy.md)
- [UniversalRP](https://github.com/hecomi/uRaymarching/blob/master/Documents/UniversalRP.md)

Please see each template file by clicking *Edit* button on the right side of the *Shader Template* drop-down list for more details.


Export
------
<img src="https://raw.githubusercontent.com/wiki/hecomi/uRaymarching/export.png" width="720" />

Press *Export* button or *Ctrl + R* to export shader. Then, press *Create Material* button to generate a material which uses the shader (or create a material manually from the *Project* pane).


Material
--------
<img src="https://raw.githubusercontent.com/wiki/hecomi/uRaymarching/material-properties.png" width="720" />

- Loop
  - The maximum number of loops of raymarching in basic passes.
- Minimum Distance
  - If the distance returned by a distance function becomes lower than this value, the loop finishes.
- Distance Multiplier
  - This value is multiplied by the output of a distance function.
- Shadow Loop
  - The maximum number of loops of raymarching in shadow pass.
- Shadow Minimum Distance
  - *Minimum Distance* in shadow pass.
- Shadow Extra Bias
  - Additional shadow bias to avoid shadow acne.

